// Generated by CoffeeScript 2.1.0
var Nav;

Nav = class Nav {
  constructor(canv, data, bgcolor, root) {
    var img_src;
    this.draw = this.draw.bind(this);
    this.mouseover_check = this.mouseover_check.bind(this);
    // handle mouseclick events based on where the mouse is hovering
    this.mouseclick_check = this.mouseclick_check.bind(this);
    this.canv = canv;
    this.data = data;
    this.bgcolor = bgcolor;
    this.root = root;
    this.mousover = null;
    this.ratio = this.canv.width / this.canv.height;
    this.orig_dim = {
      w: data.size.w,
      h: data.size.h
    };
    this.curr_dim = {
      w: data.size.w,
      h: data.size.h
    };
    this.active = getComputedStyle(this.canv).display !== "none";
    this.ani = {
      active: false,
      states: {
        home: 0,
        projects: 0,
        log: 0,
        about: 0,
        contact: 0
      },
      steps: {
        // these are px values for each step of the cover animation
        home: [(root === 'home') * 38, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
        projects: [(root === 'projects') * 38, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
        log: [(root === 'log') * 28, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
        about: [(root === 'about') * 22, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
        contact: [(root === 'contact') * 28, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
      }
    };
    // home:     [ (root is 'home') * 4,     5, 5, 5, 4 ],
    // projects: [ (root is 'projects') * 4, 5, 5, 5, 4 ],
    // log:      [ (root is 'log') * 3,      5, 5, 4 ],
    // about:    [ (root is 'about') * 3,    5, 2, 4 ],
    // contact:  [ (root is 'contact') * 3,  5, 5, 4 ]
    img_src = "/assets/media/images/sword-nav.png";
    // load initial image
    this.img = new Image();
    this.img.onload = () => {
      return this.load_img();
    };
    this.img.src = img_src;
    this.scale();
    // set mouse listeners
    this.canv.addEventListener('mousemove', this.mouseover_check);
    this.canv.addEventListener('click', this.mouseclick_check);
    // set resize listener
    window.addEventListener('resize', () => {
      this.active = getComputedStyle(this.canv).display !== "none";
      if (this.active && this.canv.parentNode.offsetWidth !== this.curr_dim.w) {
        console.log("Aasbd");
        return this.scale();
      }
    });
  }

  scale() {
    var ctx;
    this.canv.width = this.curr_dim.w = this.canv.parentNode.offsetWidth;
    this.canv.height = this.curr_dim.h = this.curr_dim.w / this.ratio;
    ctx = this.canv.getContext('2d');
    ctx.imageSmoothingEnabled = false;
    ctx.mozImageSmoothingEnabled = false;
    ctx.webkitImageSmoothingEnabled = false;
    ctx.msImageSmoothingEnabled = false;
    return this.load_img();
  }

  /*
  ANIMATION WALKTHROUGH

  store current cover sizes (in width) for each label
  - the bounds are [0, @data.labels.$label.w]
  - do not include the root label

  also store the animation states for each
  -  1: reduce clearRect size
  -  0: keep size
  - -1: increase clearRect size

  size-delta is equal to get_scaling() in px

  steps:
  - save frame with sword
  - while all states are not 0:
    - increase/decrease each cover by delta based on animation state
    - if that cover hits a terminal size, set state to 0
  - when mouse enters a label/rune, set its state to 1
  - when mouse leaves a label/rune, set its state to -1

  */
  check_to_ani() {
    var label, ref, state, to_ani;
    to_ani = false;
    ref = this.ani.states;
    for (label in ref) {
      state = ref[label];
      to_ani = to_ani || state !== 0;
    }
    return to_ani;
  }

  update_ani_states() {
    var label, ref, results, state, steps;
    ref = this.ani.steps;
    results = [];
    for (label in ref) {
      steps = ref[label];
      state = this.ani.states[label];
      switch (state) {
        case -1:
          if (steps[0] > 0) {
            results.push(steps[0] = steps[0] + state);
          } else {
            results.push(this.ani.states[label] = 0);
          }
          break;
        case 1:
          if (steps[0] + 1 < steps.length) {
            results.push(steps[0] = steps[0] + state);
          } else {
            results.push(this.ani.states[label] = 0);
          }
          break;
        default:
          results.push(void 0);
      }
    }
    return results;
  }

  draw() {
    this.ani.active = this.check_to_ani();
    if (!this.ani.active) {
      return;
    }
    this.update_ani_states();
    this.load_img(); // this will render a new canvas with
    return window.requestAnimationFrame(this.draw);
  }

  load_img() {
    var scale;
    // how much should we scale the pixel art?
    scale = this.get_scaling();
    this.canv.getContext('2d').drawImage(this.img, 0, 0, scale * this.orig_dim.w, scale * this.orig_dim.h); // source and (x,y) pos // width // height
    this.load_coverup(); // make the label coverups
    return this.color_runes();
  }

  
  load_coverup() {
    var data, h, label, r, ref, results, shrink_by, steps, w, x, y;
    ref = this.data.labels;
    results = [];
    for (label in ref) {
      data = ref[label];
      if (label !== "range" && label !== this.root) {
        r = data.range;
        steps = this.ani.steps[label];
        shrink_by = steps[0] ? steps.slice(1, +steps[0] + 1 || 9e9).reduce(function(a, b) {
          return a + b;
        }) : 0;
        y = r.min.y;
        w = r.max.x - r.min.x - shrink_by;
        x = r.min.x + shrink_by;
        h = r.max.y - y;
        results.push(this.draw_coverup(x, y, w, h));
      } else {
        results.push(void 0);
      }
    }
    return results;
  }

  // draw a rectangle of ( size, size ) at ( x, y ) of the background color
  draw_coverup(x, y, w, h) {
    var ctx, sc;
    sc = this.get_scaling();
    ctx = this.canv.getContext('2d');
    ctx.fillStyle = this.bgcolor;
    return ctx.fillRect(x * sc, y * sc, w * sc, h * sc);
  }

  color_runes() {
    var ctx, i, j, len, len1, px, ref, ref1, results, sc;
    sc = this.get_scaling();
    ctx = this.canv.getContext('2d');
    ctx.fillStyle = 'red';
    ref = this.data.runes[this.root].px;
    for (i = 0, len = ref.length; i < len; i++) {
      px = ref[i];
      ctx.fillRect(px.x * sc, px.y * sc, sc, sc);
    }
    if (this.mouseover) {
      ref1 = this.data.runes[this.mouseover].px;
      results = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        px = ref1[j];
        results.push(ctx.fillRect(px.x * sc, px.y * sc, sc, sc));
      }
      return results;
    }
  }

  mouseover_check(ev) {
    var crect, k, label_range, ref, rune_range, sc, v, x, y;
    x = y = 0;
    crect = this.canv.getBoundingClientRect();
    x = ev.clientX - crect.left;
    y = ev.clientY - crect.top;
    sc = this.get_scaling();
    rune_range = this.data.runes.range;
    label_range = this.data.labels.range;
    this.mouseover = this.mouseover_rune(x, y, sc);
    // console.log @mouseover
    this.mouseover = this.mouseover ? this.mouseover : this.mouseover_label(x, y, sc);
    // console.log @mouseover
    if (this.mouseover) {
      this.canv.style.cursor = "pointer";
      if (this.mouseover !== this.root) {
        this.ani.states[this.mouseover] = 1;
      }
    } else {
      this.canv.style.cursor = "default";
    }
    ref = this.ani.states;
    for (k in ref) {
      v = ref[k];
      if (k !== this.root && k !== this.mouseover) { //and v != 0
        this.ani.states[k] = -1;
      }
    }
    return this.draw();
  }

  // return the label that the mouse is over, or null if not
  mouseover_label(x, y, sc) {
    var data, label, r, ref;
    ref = this.data.labels;
    for (label in ref) {
      data = ref[label];
      if (label !== 'range') {
        r = data.range;
        if (x >= r.min.x * sc && x <= r.max.x * sc && y >= r.min.y * sc && y <= r.max.y * sc) {
          return label;
        }
      }
    }
    this.canv.style.cursor = "default";
    return null;
  }

  // return the rune that the mouse is over, or null if not
  mouseover_rune(x, y, sc) {
    var data, r, ref, rune;
    ref = this.data.runes;
    for (rune in ref) {
      data = ref[rune];
      // console.log rune, data
      if (rune !== 'range') {
        r = data.range;
        if (x >= r.min.x * sc && x <= r.max.x * sc && y >= r.min.y * sc && y <= r.max.y * sc) {
          return rune;
        }
      }
    }
    this.canv.style.cursor = "default";
    return null;
  }

  mouseclick_check(ev) {
    if (this.mouseover === "home") {
      return window.open("/", "_self");
    } else if (this.mouseover) {
      return window.open(`/${this.mouseover}`, "_self");
    }
  }

  // return the image scaling for pxel proportions
  get_scaling() {
    return Math.floor(this.curr_dim.w / this.orig_dim.w);
  }

};
